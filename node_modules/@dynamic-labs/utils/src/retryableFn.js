import { __awaiter } from '../_virtual/_tslib.js';

const FALLBACK_UNDEFINED = 'FALLBACK_UNDEFINED';
const retryableFn = (fn, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const { maxRetries = 3, currentRetry = 0, timeoutMs = 100, fallbackValue = new Error('Max retries reached'), retryStrategy = 'timeout-only', } = options;
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
            reject(new Error('Timeout'));
        }, timeoutMs);
    });
    try {
        const result = yield Promise.race([fn(), timeoutPromise]);
        return result;
    }
    catch (err) {
        if (currentRetry >= maxRetries) {
            if (fallbackValue instanceof Error) {
                throw fallbackValue;
            }
            else if (fallbackValue === FALLBACK_UNDEFINED) {
                return undefined;
            }
            return fallbackValue;
        }
        const isTimeout = err.message === 'Timeout';
        const shouldRetry = retryStrategy === 'timeout-and-rejection' ||
            (retryStrategy === 'timeout-only' && isTimeout) ||
            (retryStrategy === 'rejection-only' && !isTimeout);
        if (!shouldRetry) {
            if (fallbackValue instanceof Error) {
                throw err;
            }
            else if (fallbackValue === FALLBACK_UNDEFINED) {
                return undefined;
            }
            return fallbackValue;
        }
        return retryableFn(fn, {
            currentRetry: currentRetry + 1,
            fallbackValue,
            maxRetries,
            retryStrategy,
            timeoutMs,
        });
    }
});

export { FALLBACK_UNDEFINED, retryableFn };
