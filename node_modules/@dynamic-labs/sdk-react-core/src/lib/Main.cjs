'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var utils = require('@dynamic-labs/utils');
require('@dynamic-labs/sdk-api');
require('./shared/logger.cjs');
require('@dynamic-labs/iconic');
require('@dynamic-labs/wallet-connector-core');
var ViewContext = require('./context/ViewContext/ViewContext.cjs');
require('@dynamic-labs/wallet-book');
var localStorage$1 = require('./utils/constants/localStorage.cjs');
require('./utils/constants/colors.cjs');
var localStorage = require('./shared/utils/classes/storage/localStorage.cjs');
require('viem');
var usePreventPageScroll = require('./shared/utils/hooks/usePreventPageScroll/usePreventPageScroll.cjs');
var index$1 = require('./shared/consts/index.cjs');
var useInternalDynamicContext = require('./context/DynamicContext/useInternalDynamicContext.cjs');
require('@dynamic-labs/multi-wallet');
var isSupportedNetwork = require('./utils/functions/isSupportedNetwork/isSupportedNetwork.cjs');
require('./components/ShadowDOM/ShadowDOM.cjs');
require('./context/ThemeContext/ThemeContext.cjs');
var Portal = require('./components/Portal/Portal.cjs');
require('react-dom');
require('./config/ApiEndpoint.cjs');
require('@dynamic-labs/rpc-providers');
require('./utils/hooks/useWallets/utils/verifyMagicIsSetup/verifyMagicIsSetup.cjs');
var isSameWalletName = require('./utils/functions/isSameWalletName/isSameWalletName.cjs');
require('./context/ErrorContext/ErrorContext.cjs');
var AccessDeniedContext = require('./context/AccessDeniedContext/AccessDeniedContext.cjs');
var AccountExistsContext = require('./context/AccountExistsContext/AccountExistsContext.cjs');
require('react-i18next');
var DynamicAuthModal = require('./modals/DynamicAuthModal/DynamicAuthModal.cjs');
require('./components/IconButton/IconButton.cjs');
require('./components/Transition/ZoomTransition/ZoomTransition.cjs');
require('./components/Transition/SlideInUpTransition/SlideInUpTransition.cjs');
require('./components/Transition/OpacityTransition/OpacityTransition.cjs');
require('./components/Alert/Alert.cjs');
require('formik');
require('yup');
require('./context/MockContext/MockContext.cjs');
var useWalletItemActions = require('./utils/hooks/useWalletItemActions/useWalletItemActions.cjs');
var isConnectOnly = require('./utils/hooks/authenticationHooks/helpers/isConnectOnly.cjs');
require('./context/CaptchaContext/CaptchaContext.cjs');
require('./context/EmailVerificationContext/EmailVerificationContext.cjs');
require('@dynamic-labs/types');
require('./utils/hooks/useUserUpdateRequest/useUpdateUser/useUpdateUser.cjs');
require('./context/UserFieldEditorContext/UserFieldEditorContext.cjs');
require('./components/Popper/Popper/Popper.cjs');
var PopperContext = require('./components/Popper/PopperContext/PopperContext.cjs');
require('./components/InlineWidget/InlineWidget.cjs');
require('./components/MenuList/Dropdown/Dropdown.cjs');
require('./components/OverlayCard/OverlayCard.context.cjs');
var index = require('./context/FooterAnimationContext/index.cjs');
var SocialRedirectContext = require('./context/SocialRedirectContext/SocialRedirectContext.cjs');
var isSelectedWalletAlreadyConnected = require('./utils/functions/isSelectedWalletAlreadyConnected/isSelectedWalletAlreadyConnected.cjs');
var useVerifyOnAwaitingSignature = require('./utils/hooks/multiWallet/useVerifyOnAwaitingSignature/useVerifyOnAwaitingSignature.cjs');
var viewToComponentMap = require('./views/viewToComponentMap.cjs');
require('./main.global.cjs');

const viewsToDisableCloseOnOverlayClick = [
    'email-wallet-otp-verification-view',
    'social-redirect-view',
    'passkey-intro',
];
const Main = () => {
    const { selectedWalletConnector, linkedWallets, isProjectSettingsLoading, projectSettings, setShowAuthFlow, showAuthFlow, wallets, clearStatesOnBackClick, user, disconnectWallet, authMode, connectedWallets, handleLogOut, } = useInternalDynamicContext.useInternalDynamicContext();
    const { view, goToInitialView } = ViewContext.useViewContext();
    const { setDeniedAddress, setDeniedOauthProvider } = AccessDeniedContext.useAccessDeniedContext();
    const { setExistentAccountData } = AccountExistsContext.useAccountExistsContext();
    usePreventPageScroll.usePreventPageScroll(showAuthFlow);
    const userWallets = authMode === 'connect-and-sign' ? linkedWallets : connectedWallets;
    const handleClose = () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        if (viewsToDisableCloseOnOverlayClick.includes(view))
            return;
        if ((view === 'network-not-supported' ||
            view === 'network-not-supported-manual') &&
            userWallets.length === 1) {
            yield handleLogOut();
        }
        setShowAuthFlow(false);
        setDeniedAddress('');
        setDeniedOauthProvider(undefined);
        setExistentAccountData(undefined);
        clearStatesOnBackClick();
    });
    const handleOnPortalExiting = React.useCallback(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        // In the connect only mode (default and bridge)
        // We want to disconnect wallet when users closes `network not supported` view
        // without updating network in wallet
        // We use onExiting instead onUnmount to avoid jump effect in inline widget
        if (isConnectOnly.isConnectOnly(user, authMode)) {
            const viewsToDisconnectWalletOnClose = [
                'network-not-supported',
                'network-not-supported-manual',
            ];
            if (viewsToDisconnectWalletOnClose.includes(view)) {
                if (!selectedWalletConnector) {
                    return;
                }
                const walletByConnectorName = connectedWallets.find((connectedWallet) => connectedWallet.connector.name === selectedWalletConnector.name);
                if (!walletByConnectorName) {
                    return;
                }
                // Validate the network
                if (!isSupportedNetwork.isSupportedNetwork({
                    network: yield walletByConnectorName.connector.getNetwork(),
                    walletConnector: walletByConnectorName.connector,
                })) {
                    disconnectWallet(walletByConnectorName.id);
                }
            }
        }
    }), [
        selectedWalletConnector,
        authMode,
        connectedWallets,
        disconnectWallet,
        user,
        view,
    ]);
    const handleOnPortalUnmount = React.useCallback(() => {
        // IMPORTANT: we need to reset the view because we reset state that the view depends on
        // so if the previous view renders when the user reopens the widget, it will crash
        goToInitialView();
    }, [goToInitialView]);
    useVerifyOnAwaitingSignature.useVerifyOnAwaitingSignature();
    const { handleAlreadyConnectedWallet, handleCustodialWalletClick, handleInstalledExtensionClick, handleMobileWalletClick, handleUninstalledClick, } = useWalletItemActions.useWalletItemActions();
    /* istanbul ignore next */
    const handleNewToWeb3WalletIntent = (walletConnector) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        setShowAuthFlow(true);
        if (isSelectedWalletAlreadyConnected.isSelectedWalletAlreadyConnected(linkedWallets, walletConnector, user)) {
            // wallet is already connected
            handleAlreadyConnectedWallet(walletConnector);
        }
        else if (walletConnector.canConnectViaCustodialService) {
            // providers like blocto and dapper
            handleCustodialWalletClick(walletConnector);
        }
        else if (utils.isMobile()) {
            // mobile wallets
            handleMobileWalletClick(walletConnector);
        }
        else if (walletConnector.isInstalledOnBrowser()) {
            // browser extensions or injected wallets
            handleInstalledExtensionClick(walletConnector);
        }
        else {
            // wallet requiring a qr code (wallet connect/coinbase wallet)
            handleUninstalledClick(walletConnector);
        }
    });
    React.useEffect(() => {
        const newToWeb3WalletName = localStorage.LocalStorage.getFromLS(localStorage$1.NEWTOWEB3_WALLET_EXTENSION_FLAG_KEY);
        if ((wallets === null || wallets === void 0 ? void 0 : wallets.length) && newToWeb3WalletName) {
            const wallet = wallets.find((wallet) => isSameWalletName.isSameWalletName(wallet.name, newToWeb3WalletName));
            if (wallet === null || wallet === void 0 ? void 0 : wallet.walletConnector) {
                handleNewToWeb3WalletIntent(wallet.walletConnector);
            }
            localStorage.LocalStorage.removeFromLS(localStorage$1.NEWTOWEB3_WALLET_EXTENSION_FLAG_KEY);
        }
    }, [wallets]);
    const showDynamicAuth = showAuthFlow && !isProjectSettingsLoading;
    return (jsxRuntime.jsx(SocialRedirectContext.SocialRedirectContextProvider, { children: jsxRuntime.jsx(index.FooterAnimationContextProvider, { children: jsxRuntime.jsx(Portal.Portal, { zIndex: index$1.authModalZIndex, isShown: showDynamicAuth, handleClose: handleClose, withBackdrop: true, transitionEvents: {
                    onExiting: handleOnPortalExiting,
                    onUnmount: handleOnPortalUnmount,
                }, children: jsxRuntime.jsx(PopperContext.PopperProvider, { children: jsxRuntime.jsx(DynamicAuthModal.DynamicAuthModal, { transitionProps: {
                            isShown: showDynamicAuth,
                        }, onClose: handleClose, projectSettings: projectSettings, walletConnector: selectedWalletConnector, children: viewToComponentMap.viewToComponentMap[view] }) }) }) }) }));
};

exports.Main = Main;
exports["default"] = Main;
